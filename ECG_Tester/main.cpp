#include "mbed.h"
#include "max86908_map.h"
#include "max89608_driver.h"

#define NUM_SAMPLES_NN_INPUT    320

typedef struct __attribute__((packed)) {
    uint8_t data_rdy;
    uint8_t *read_buff;
    uint8_t *read_buff_shadow;
    int32_t *corrected_input;
} Thread_struct_t;

Thread_struct_t thread_struct;

InterruptIn edge_det(P9_5);
DigitalOut dbg_1(P0_2);
DigitalOut dbg_2(P5_6);

//Thread thread(osPriorityBelowNormal);
Thread thread;
RawSerial kp_uart(UART_TX, UART_RX);

uint8_t *wr_ptr;
volatile uint8_t int_det_flag = 0;


uint8_t read_buf[NUM_SAMPLES_NN_INPUT*3], read_buf_shadow[NUM_SAMPLES_NN_INPUT*3];
int32_t corrected_input[NUM_SAMPLES_NN_INPUT];


int32_t test_array[NUM_SAMPLES_NN_INPUT] ={0,5147,10292,15433,20568,25695,30812,35917,41008,46084,51142,56180,61196,66189,71156,76096,81007,85886,90733,95544,100318,105054,109749,114402,119011,123574,128089,132555,136970,141332,145639,149891,154084,158219,162292,166302,170249,174130,177944,181689,185364,188967,192498,195955,199336,202640,205866,209013,212079,215063,217965,220782,223515,226161,228720,231190,233572,235864,238064,240173,242189,244112,245941,247675,249314,250856,252302,253650,254901,256053,257107,258062,258917,259672,260327,260882,261336,261689,261942,262093,262144,262093,261942,261689,261336,260882,260327,259672,258917,258062,257107,256053,254901,253650,252302,250856,249314,247675,245941,244112,242189,240173,238064,235864,233572,231190,228720,226161,223515,220782,217965,215063,212079,209013,205866,202640,199336,195955,192498,188967,185364,181689,177944,174130,170249,166302,162292,158219,154084,149891,145639,141332,136970,132555,128089,123574,119011,114402,109749,105054,100318,95544,90733,85886,81007,76096,71156,66189,61196,56180,51142,46084,41008,35917,30812,25695,20568,15433,10292,5147,0,-5147,-10292,-15433,-20568,-25695,-30812,-35917,-41008,-46084,-51142,-56180,-61196,-66189,-71156,-76096,-81007,-85886,-90733,-95544,-100318,-105054,-109749,-114402,-119011,-123574,-128089,-132555,-136970,-141332,-145639,-149891,-154084,-158219,-162292,-166302,-170249,-174130,-177944,-181689,-185364,-188967,-192498,-195955,-199336,-202640,-205866,-209013,-212079,-215063,-217965,-220782,-223515,-226161,-228720,-231190,-233572,-235864,-238064,-240173,-242189,-244112,-245941,-247675,-249314,-250856,-252302,-253650,-254901,-256053,-257107,-258062,-258917,-259672,-260327,-260882,-261336,-261689,-261942,-262093,-262144,-262093,-261942,-261689,-261336,-260882,-260327,-259672,-258917,-258062,-257107,-256053,-254901,-253650,-252302,-250856,-249314,-247675,-245941,-244112,-242189,-240173,-238064,-235864,-233572,-231190,-228720,-226161,-223515,-220782,-217965,-215063,-212079,-209013,-205866,-202640,-199336,-195955,-192498,-188967,-185364,-181689,-177944,-174130,-170249,-166302,-162292,-158219,-154084,-149891,-145639,-141332,-136970,-132555,-128089,-123574,-119011,-114402,-109749,-105054,-100318,-95544,-90733,-85886,-81007,-76096,-71156,-66189,-61196,-56180,-51142,-46084,-41008,-35917,-30812,-25695,-20568,-15433,-10292,-5147};

uint8_t test_read_buf[NUM_SAMPLES_NN_INPUT*3] = {0x00,0x00,0x00,0x00,0x0A,0x0D,0x00,0x14,0x1A,0x00,0x1E,0x24,0x00,0x28,0x2C,0x00,0x32,0x2F,0x00,0x3C,0x2E,0x00,0x46,0x26,0x00,0x50,0x18,0x00,0x5A,0x02,0x00,0x63,0xE3,0x00,0x6D,0xBA,0x00,0x77,0x86,0x00,0x81,0x47,0x00,0x8A,0xFA,0x00,0x94,0xA0,0x00,0x9E,0x37,0x00,0xA7,0xBF,0x00,0xB1,0x36,0x00,0xBA,0x9C,0x00,0xC3,0xEF,0x00,0xCD,0x2F,0x00,0xD6,0x5B,0x00,0xDF,0x71,0x00,0xE8,0x71,0x00,0xF1,0x5B,0x00,0xFA,0x2D,0x01,0x02,0xE6,0x01,0x0B,0x85,0x01,0x14,0x0A,0x01,0x1C,0x74,0x01,0x24,0xC1,0x01,0x2C,0xF2,0x01,0x35,0x05,0x01,0x3C,0xFA,0x01,0x44,0xCF,0x01,0x4C,0x84,0x01,0x54,0x19,0x01,0x5B,0x8C,0x01,0x62,0xDC,0x01,0x6A,0x0A,0x01,0x71,0x14,0x01,0x77,0xF9,0x01,0x7E,0xB9,0x01,0x85,0x54,0x01,0x8B,0xC8,0x01,0x92,0x15,0x01,0x98,0x3A,0x01,0x9E,0x37,0x01,0xA4,0x0C,0x01,0xA9,0xB6,0x01,0xAF,0x37,0x01,0xB4,0x8D,0x01,0xB9,0xB8,0x01,0xBE,0xB8,0x01,0xC3,0x8B,0x01,0xC8,0x32,0x01,0xCC,0xAC,0x01,0xD0,0xF8,0x01,0xD5,0x17,0x01,0xD9,0x07,0x01,0xDC,0xC8,0x01,0xE0,0x5B,0x01,0xE3,0xBE,0x01,0xE6,0xF1,0x01,0xE9,0xF4,0x01,0xEC,0xC7,0x01,0xEF,0x69,0x01,0xF1,0xDA,0x01,0xF4,0x1B,0x01,0xF6,0x29,0x01,0xF8,0x07,0x01,0xF9,0xB2,0x01,0xFB,0x2C,0x01,0xFC,0x73,0x01,0xFD,0x89,0x01,0xFE,0x6C,0x01,0xFF,0x1D,0x01,0xFF,0x9B,0x01,0xFF,0xE7,0x02,0x00,0x00,0x01,0xFF,0xE7,0x01,0xFF,0x9B,0x01,0xFF,0x1D,0x01,0xFE,0x6C,0x01,0xFD,0x89,0x01,0xFC,0x73,0x01,0xFB,0x2C,0x01,0xF9,0xB2,0x01,0xF8,0x07,0x01,0xF6,0x29,0x01,0xF4,0x1B,0x01,0xF1,0xDA,0x01,0xEF,0x69,0x01,0xEC,0xC7,0x01,0xE9,0xF4,0x01,0xE6,0xF1,0x01,0xE3,0xBE,0x01,0xE0,0x5B,0x01,0xDC,0xC8,0x01,0xD9,0x07,0x01,0xD5,0x17,0x01,0xD0,0xF8,0x01,0xCC,0xAC,0x01,0xC8,0x32,0x01,0xC3,0x8B,0x01,0xBE,0xB8,0x01,0xB9,0xB8,0x01,0xB4,0x8D,0x01,0xAF,0x37,0x01,0xA9,0xB6,0x01,0xA4,0x0C,0x01,0x9E,0x37,0x01,0x98,0x3A,0x01,0x92,0x15,0x01,0x8B,0xC8,0x01,0x85,0x54,0x01,0x7E,0xB9,0x01,0x77,0xF9,0x01,0x71,0x14,0x01,0x6A,0x0A,0x01,0x62,0xDC,0x01,0x5B,0x8C,0x01,0x54,0x19,0x01,0x4C,0x84,0x01,0x44,0xCF,0x01,0x3C,0xFA,0x01,0x35,0x05,0x01,0x2C,0xF2,0x01,0x24,0xC1,0x01,0x1C,0x74,0x01,0x14,0x0A,0x01,0x0B,0x85,0x01,0x02,0xE6,0x00,0xFA,0x2D,0x00,0xF1,0x5B,0x00,0xE8,0x71,0x00,0xDF,0x71,0x00,0xD6,0x5B,0x00,0xCD,0x2F,0x00,0xC3,0xEF,0x00,0xBA,0x9C,0x00,0xB1,0x36,0x00,0xA7,0xBF,0x00,0x9E,0x37,0x00,0x94,0xA0,0x00,0x8A,0xFA,0x00,0x81,0x47,0x00,0x77,0x86,0x00,0x6D,0xBA,0x00,0x63,0xE3,0x00,0x5A,0x02,0x00,0x50,0x18,0x00,0x46,0x26,0x00,0x3C,0x2E,0x00,0x32,0x2F,0x00,0x28,0x2C,0x00,0x1E,0x24,0x00,0x14,0x1A,0x00,0x0A,0x0D,0x00,0x00,0x00,0x03,0xF5,0xF3,0x03,0xEB,0xE6,0x03,0xE1,0xDC,0x03,0xD7,0xD4,0x03,0xCD,0xD1,0x03,0xC3,0xD2,0x03,0xB9,0xDA,0x03,0xAF,0xE8,0x03,0xA5,0xFE,0x03,0x9C,0x1D,0x03,0x92,0x46,0x03,0x88,0x7A,0x03,0x7E,0xB9,0x03,0x75,0x06,0x03,0x6B,0x60,0x03,0x61,0xC9,0x03,0x58,0x41,0x03,0x4E,0xCA,0x03,0x45,0x64,0x03,0x3C,0x11,0x03,0x32,0xD1,0x03,0x29,0xA5,0x03,0x20,0x8F,0x03,0x17,0x8F,0x03,0x0E,0xA5,0x03,0x05,0xD3,0x02,0xFD,0x1A,0x02,0xF4,0x7B,0x02,0xEB,0xF6,0x02,0xE3,0x8C,0x02,0xDB,0x3F,0x02,0xD3,0x0E,0x02,0xCA,0xFB,0x02,0xC3,0x06,0x02,0xBB,0x31,0x02,0xB3,0x7C,0x02,0xAB,0xE7,0x02,0xA4,0x74,0x02,0x9D,0x24,0x02,0x95,0xF6,0x02,0x8E,0xEC,0x02,0x88,0x07,0x02,0x81,0x47,0x02,0x7A,0xAC,0x02,0x74,0x38,0x02,0x6D,0xEB,0x02,0x67,0xC6,0x02,0x61,0xC9,0x02,0x5B,0xF4,0x02,0x56,0x4A,0x02,0x50,0xC9,0x02,0x4B,0x73,0x02,0x46,0x48,0x02,0x41,0x48,0x02,0x3C,0x75,0x02,0x37,0xCE,0x02,0x33,0x54,0x02,0x2F,0x08,0x02,0x2A,0xE9,0x02,0x26,0xF9,0x02,0x23,0x38,0x02,0x1F,0xA5,0x02,0x1C,0x42,0x02,0x19,0x0F,0x02,0x16,0x0C,0x02,0x13,0x39,0x02,0x10,0x97,0x02,0x0E,0x26,0x02,0x0B,0xE5,0x02,0x09,0xD7,0x02,0x07,0xF9,0x02,0x06,0x4E,0x02,0x04,0xD4,0x02,0x03,0x8D,0x02,0x02,0x77,0x02,0x01,0x94,0x02,0x00,0xE3,0x02,0x00,0x65,0x02,0x00,0x19,0x02,0x00,0x00,0x02,0x00,0x19,0x02,0x00,0x65,0x02,0x00,0xE3,0x02,0x01,0x94,0x02,0x02,0x77,0x02,0x03,0x8D,0x02,0x04,0xD4,0x02,0x06,0x4E,0x02,0x07,0xF9,0x02,0x09,0xD7,0x02,0x0B,0xE5,0x02,0x0E,0x26,0x02,0x10,0x97,0x02,0x13,0x39,0x02,0x16,0x0C,0x02,0x19,0x0F,0x02,0x1C,0x42,0x02,0x1F,0xA5,0x02,0x23,0x38,0x02,0x26,0xF9,0x02,0x2A,0xE9,0x02,0x2F,0x08,0x02,0x33,0x54,0x02,0x37,0xCE,0x02,0x3C,0x75,0x02,0x41,0x48,0x02,0x46,0x48,0x02,0x4B,0x73,0x02,0x50,0xC9,0x02,0x56,0x4A,0x02,0x5B,0xF4,0x02,0x61,0xC9,0x02,0x67,0xC6,0x02,0x6D,0xEB,0x02,0x74,0x38,0x02,0x7A,0xAC,0x02,0x81,0x47,0x02,0x88,0x07,0x02,0x8E,0xEC,0x02,0x95,0xF6,0x02,0x9D,0x24,0x02,0xA4,0x74,0x02,0xAB,0xE7,0x02,0xB3,0x7C,0x02,0xBB,0x31,0x02,0xC3,0x06,0x02,0xCA,0xFB,0x02,0xD3,0x0E,0x02,0xDB,0x3F,0x02,0xE3,0x8C,0x02,0xEB,0xF6,0x02,0xF4,0x7B,0x02,0xFD,0x1A,0x03,0x05,0xD3,0x03,0x0E,0xA5,0x03,0x17,0x8F,0x03,0x20,0x8F,0x03,0x29,0xA5,0x03,0x32,0xD1,0x03,0x3C,0x11,0x03,0x45,0x64,0x03,0x4E,0xCA,0x03,0x58,0x41,0x03,0x61,0xC9,0x03,0x6B,0x60,0x03,0x75,0x06,0x03,0x7E,0xB9,0x03,0x88,0x7A,0x03,0x92,0x46,0x03,0x9C,0x1D,0x03,0xA5,0xFE,0x03,0xAF,0xE8,0x03,0xB9,0xDA,0x03,0xC3,0xD2,0x03,0xCD,0xD1,0x03,0xD7,0xD4,0x03,0xE1,0xDC,0x03,0xEB,0xE6,0x03,0xF5,0xF3};



int32_t process_filter(int32_t input)
{
     /* 60Hz band stop, 200Hz sample rate coeff */
    // float coefficients_xn[3] = {0.662460565567017,0.102763175964355,0.662460565567017};
    // float coefficients_yn[2] = {0.102763175964355, 0.324919700622559};
    /* 20Hz low pass, 200Hz sample rate coeff */
    float coefficients_xn[3] = {0.0200834274291992, 0.0401668548583984, 0.0200834274291992};
    float coefficients_yn[2] = {-1.56101822853088, 0.641351699829102};

    static int32_t xn_1 = 0, xn_2 = 0, yn_1 = 0, yn_2 = 0;
    int32_t output;

    /* Biquad */
    output = input*coefficients_xn[0] + xn_1 * coefficients_xn[1]  + xn_2 * coefficients_xn[2] - yn_1 * coefficients_yn[0] - yn_2 *coefficients_yn[1];
    xn_2 = xn_1;
    xn_1 = input;
    
    yn_2 = yn_1;
    yn_1 = output;
    

    return(output);

}

void TF_thread(Thread_struct_t *thread_struct) 
{
    uint8_t *read_ptr;
    uint32_t loop;
    uint8_t header[2] = {0x17, 0xAB};
    float testout[2] = {0.1, 0.9};
    float normalized_input[320];

    while(1)
    {
        
        if(thread_struct->data_rdy)
        {
            int32_t max=0, min=0;
            dbg_2.write(1); 

            if(wr_ptr == read_buf_shadow)
            {
               read_ptr = read_buf; 
            }
            else
            {
                read_ptr = read_buf_shadow;
            }
            
            //read_ptr = test_read_buf;

            for(loop = 0; loop < NUM_SAMPLES_NN_INPUT ; loop++)
            {   
                uint8_t curr_samp_hi =  *(read_ptr + loop*3);
                uint8_t curr_samp_mid = *(read_ptr + loop*3 + 1);
                uint8_t curr_samp_low = *(read_ptr + loop*3 + 2);

                
                /* Clear any old data */
                corrected_input[loop] = 0;
                
                /* Check for 18th bit high */
                if(curr_samp_hi & (0x02))
                {   
                    /* Extend sign to full 32-bits */
                    corrected_input[loop] |= 0xFFFE0000; 
                }

                corrected_input[loop] |= (uint32_t) (curr_samp_hi << 16);
                corrected_input[loop] |= (uint32_t) (curr_samp_mid << 8);
                corrected_input[loop] |= (uint32_t) (curr_samp_low);
            
                corrected_input[loop] = process_filter(corrected_input[loop]);

                if(corrected_input[loop] > max)
                {
                    max = corrected_input[loop];
                }

                if(corrected_input[loop] < min)
                {
                    min = corrected_input[loop];
                }
            }

            /* Normalize input */
            for(loop = 0; loop < NUM_SAMPLES_NN_INPUT ; loop++)
            {
                  normalized_input[loop] = (corrected_input[loop] - min)/(max-min);
            }

            /* Send output */
            kp_uart.putc(header[0]);
            kp_uart.putc(header[1]);

            for(loop = 0; loop < sizeof(testout) ; loop++)
            {
                
                kp_uart.putc((uint8_t)*((uint8_t *)&testout + loop));
            }

            /* Send input */
            for(loop = 0; loop < sizeof(corrected_input) ; loop++)
            {
                
                kp_uart.putc((uint8_t)*((uint8_t *)&corrected_input + loop));
            }

            thread_struct->data_rdy = 0;

            dbg_2.write(0);
        }

        ThisThread::yield();
    }
}

void int_det(void)
{
    int_det_flag = 0xFF;
}

int main() {

    thread_struct.data_rdy = 0;
    uint32_t wr_offset = 0;
    wr_ptr = read_buf;

    int_det_flag = 0;
    /* Set speed to 115200 */
    kp_uart.baud(115200);

    /* Setup edge detect */
    edge_det.mode(PullUp);
    edge_det.fall(&int_det);

    thread.start(callback(TF_thread,&thread_struct));
    
    max86xx_init();

    while(1)
    {
        
        if(int_det_flag)
        {
            
            uint8_t num_samples = max86xx_get_numsamples();

            /* Check if we aren't overflowing the available buffer */
            if((wr_offset + num_samples*3) > (sizeof(read_buf)))
            {
                /* Read the exact number of samples to fill buffer, get rest into new buffer next time */
                num_samples = (sizeof(read_buf) - wr_offset)/3;
            }

            max86xx_readfifodata(wr_ptr + wr_offset, num_samples*3);
            wr_offset += num_samples*3;
            
            int_det_flag = 0;
            if(wr_offset == (sizeof(read_buf)))
            {
                wr_offset = 0;
                if(wr_ptr == read_buf_shadow)
                {               
                    dbg_1.write(1);
                    wr_ptr = read_buf;
                }
                else 
                {
                    dbg_1.write(0);

                    wr_ptr = read_buf_shadow;
                }

                thread_struct.data_rdy = 1;

            }
            
        }
    
    }


}